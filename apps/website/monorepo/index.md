# 为什么往 monorepo 方向演进

Node.js 项目的 Git 仓库越来越倾向于采用 **Monorepo（单一代码库）** 的架构，主要原因是 **项目复杂度增加** 和 **团队协作需求提升**。

往 monorepo 方向演进的核心在于，它能够让我们，更好的做代码拆分和依赖关系的管理

## 集中管理多个模块的优势

现代 Node.js 项目通常不再是单体应用，而是由多个模块、服务、包组成，例如：

- 多个 npm 包（如 utils、core、api、cli）
- 多个微服务（如 auth-service、user-service）
- Web 与后端共存（如 frontend + backend）

**Monorepo 优点：**

| 特性                   | 说明                                                      |
| ---------------------- | --------------------------------------------------------- |
| **统一依赖管理**       | 所有模块共享依赖，减少版本冲突和冗余安装                  |
| **统一构建与发布流程** | 可以使用工具（如 TurboRepo、Nx、Lerna）管理构建/测试/发布 |
| **原子性提交**         | 一个提交可以跨多个模块进行变更，方便追踪问题              |
| **简化跨模块协作**     | 不需要在不同仓库之间切换和发布，仅通过本地引用即可调试    |

## 适配现代工具链的需求

Monorepo 的流行也和一些工具链的成熟有关：

- **Lerna** / **Nx** / **Turborepo**：支持模块依赖分析、并行任务执行、缓存等高级特性
- **PNPM workspaces** / **Yarn workspaces** / **NPM workspaces**：简化依赖和 workspace 管理
- **ESBuild、Vite、Babel** 等构建工具对 Monorepo 的支持逐渐增强

## 对大型团队更友好

在大型团队或企业中，Monorepo 可以带来更好的协作体验：

- 易于规范代码风格和测试策略
- DevOps 部署流程统一（CI/CD 更易维护）
- 更容易进行全局重构（如重命名公共 API）

## Facebook、Google 等大厂的示范效应

大型公司（如 Google、Facebook、Uber、Airbnb）早期就在使用 Monorepo，逐渐被开源社区效仿：

- React、Angular、NestJS 等大型 Node/TS 项目都采用 Monorepo
- 社区也贡献了很多相关最佳实践和工具

## 相比 Polyrepo（多个仓库）的问题

| Polyrepo 问题    | 描述                                 |
| ---------------- | ------------------------------------ |
| 版本依赖管理复杂 | 多个仓库依赖版本不一致会导致兼容问题 |
| 跨项目协作成本高 | 修改一个接口需改多个仓库并同步发布   |
| 重复构建和发布   | 每个项目都要重复设置 CI/CD 流程      |
| 脚本和工具重复   | 每个仓库需要重复维护脚本、配置等     |

## 非常适合巨石项目拆分

比如一个巨石项目，里面有 `500` 个直接依赖，可以通过把它改造成一个 `monorepo` 的方式，逐步的把依赖和逻辑拆出来，让每个包保持独立的最小化的依赖。

拆分之后，这时候可能父项目最终有 `100` 个直接共享依赖，拆分出 `20` 个子包，每个包里只有 `20` 个依赖了, 这样依赖的可维护性就好很多。

同时这样也方便进行多模块共同开发，和进行单元测试。

假如做个比喻的话，这就像，你把原先拖成一块的项目，拆分成一个一个积木，然后把积木组合起来，这个项目就能跑了。而且其中的任意模块，都是可以单独替换和发包共享的。

## 总结

在项目小的时候，Polyrepo 管理简单清晰，但随着模块增多、团队扩大，**Monorepo 提供了更高效、可维护、标准化的开发体验**，这是它越来越被 Node.js 项目采用的核心原因。
